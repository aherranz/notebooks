# Una chuleta para manejarte en Ecto ‚ñ∑ Madrid ‚ñ∑ Elixir

```elixir
Mix.install([
  # Disponible con el mismo git en el que est√° este notebook
  {:chuleta, path: "#{__DIR__}/chuleta"},

  # Me gustan los tipos, aunque s√≥lo sea para documentar
  {:typed_ecto_schema, "~> 0.4.0"}
])
```

## ANTES DE NADA: mix do ecto.drop, ecto.create

## Antes de empezar

* He intentado hacerlo **todo desde livebook** y **casi** lo consigo üòú
* El *repo git* incluye un **peque√±o proyecto** `chuleta` con una aplicaci√≥n OTP y un repositorio Ecto (justo eso es lo que no he logrado hacer desde este *notebook*)
* Me habr√≠a gustado preparar m√°s contenido pero entre lo que me he liado aprendiendo a usar *livebook* y un peque√±o proceso gripal...
* Aunque un poco ca√≥tico, creo valdr√° para aprender y **debatir** juntos

## Objetivos

* **Compartir** con vosotros esta **espectacular biblioteca**
* Ofrecer una presentaci√≥n **r√°pida y did√°ctica (espero)** a los principales conceptos
* Ofrecer algunos **patrones de c√≥digo** que creo que pueden resultar muy √∫ltiles
* Aparecer indexado por primera vez en [notes.club](https://notes.club) ü§© (disponible en https://github.com/aherranz/notebooks)

## ¬øQu√© es Ecto?

* **Biblioteca** de Elixir
* **Equivalente a un ORM** en OO (*object-relational mapping*)
* ¬°Pero **nada de objetos**!
* Expone al programador al **modelo relacional** üëç
* Uso intenso de la metaprogramaci√≥n: **DSL para las *queries*** (DSL = *domain specific language*)
* No se escribe c√≥digo SQL ü§•

## Conceptos

* **Schema:** estructura de datos para el ***mapping* entre una tabla SQL y un *struct* en Elixir** (con confundir con el esquema relacional)
* **Changeset:** üëë estructura de datos para **acumular cambios y validarlos**.
* **Queries:** estructura de datos para **codificar *queries*** a la base de datos.
* **Repo:** m√≥dulo con **operaciones** sobre la base de datos (*insert, update, delete, all, get, one, transactions*)
* **Migration:** m√≥dulo con **operaciones para modificar el esquema** de la base de datos (*create table, alter column, etc.*), incluyendo ***rollbacks* autom√°ticos**

<!-- livebook:{"break_markdown":true} -->

<!-- Learn more at https://mermaid-js.github.io/mermaid -->

```mermaid
graph TD;
  Schema -->|cambios y validaciones| Changeset;
  Datos[Datos Externos] --->|validaciones| Changeset;
  Changeset -->|cambios y validaciones| Changeset;
  Changeset -->|schema API: insert, update| Repo;
  Queries -->|query API: all, get, delete| Repo;
  Repo -->|resultado| Schema;
  Repo <--> Database[(Database)]
```

## Preparando la base de datos y el repositorio

* Vamos a trabajar con una **base de datos PostgreSQL de verdad** asi que necesitamos usuario y password

```sh
sudo -u postgres psql -c "create role chuleta login password 'chuleta' createdb;"
sudo -u postgres psql -c "create database chuleta owner chuleta;"
```

* Creamos un **repo** para conectarlo a la base de datos, ver `chuleta/lib/chuleta/repo.ex`:

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule Chuleta.Repo do
  use Ecto.Repo,
    otp_app: :chuleta,
    adapter: Ecto.Adapters.Postgres

  def init(_context, config) do
    {:ok, Keyword.put(config, :url, "ecto://chuleta:chuleta@localhost/chuleta")}
  end
end
```

* Y configuraciones en `chuleta/config/config.exs`:

<!-- livebook:{"force_markdown":true} -->

```elixir
import Config
config :chuleta, ecto_repos: [Chuleta.Repo]
```

* Es necesario crear la base de datos con:

```sh
mix ecto.create
```

## Comprobaciones previas

* La aplicaci√≥n OTP `:chuleta` est√° en marcha

```elixir
hd(Application.started_applications())
```

* El *repositorio* est√° configurado

```elixir
alias Chuleta.Repo
```

```elixir
Repo.config()
```

## Ejemplo: modelo conceptual

* Vamos a usar el mismo ejemplo del libro **Programming Ecto** de *Darin Wilson Eric Meadows-J√∂nsson*
* Base de datos de **√°lbumes musicales**: artistas, √°lbumes, g√©neros, pistas
  ```mermaid
                                  classDiagram
                                  class Album {
                                    id: integer [PK]
                                    title: string [1]
                                    released: date
                                  }
                                  class Artist {
                                    id: integer [PK]
                                    name: string [1] [unique]
                                  }
                                  class Genre {
                                    id: integer [PK]
                                    name: string [1] [unique]
                                  }
                                  class Track {
                                    id: integer [PK]
                                    title: string [1]
                                    duration: integer
                                  }
                                  Album "*" -- "1" Artist
                                  Album "*" -- "1..*" Genre
                                  Album "1" -- "1..* {ordered}" Track
  ```
* Seguro que el modelo es debatible dependiendo de lo que uno quiera entender, nos ce√±imos a la sem√°ntica del diagrama, que **a mi tampoco me gusta üòÄ**

## Un primer modelo

* Creamos **un *schema* por cada entidad** del modelo, empezamos con `Artist`

```elixir
defmodule Chuleta.Model1.Artist do
  use Ecto.Schema

  schema "artists" do
    field(:name, :string)

    # Regalo: macro para manejar autom√°ticamente fechas de inserci√≥n y borrado
    timestamps()
  end
end
```

```elixir
alias Chuleta.Model1.Artist
```

* Exploremos el ***aspecto* de los datos** (*struct* `Artist`)

```elixir
%Artist{}
```

* Seguro que ya nos asaltan algunas dudas:
  * ¬øDe d√≥nde sale `id`? ¬ø[De qu√© tipo](https://hexdocs.pm/ecto/Ecto.Schema.html#module-primary-keys) es?
  * ¬ø[De qu√© tipo](https://hexdocs.pm/elixir/NaiveDateTime.html) son `inserted_at` y `updated_at`?
  * ¬ø[Qu√© tipos](https://hexdocs.pm/ecto/Ecto.Schema.html#module-types-and-casting) puedo usar para describir los campos?

<!-- livebook:{"break_markdown":true} -->

* Ya tenemos un *schema* y un *repo* ¬øquiz√°s podamos ya **a√±adir datos**?
* Podemos intentar el [*Schema API*](https://hexdocs.pm/ecto/Ecto.Repo.html#schema-api) de `Repo`, en concreto `Repo.insert`

```elixir
Repo.insert(%Artist{})
```

* *Obviamente* **necesit√°bamos la tabla asociada**
* La creaci√≥n de una tabla se **define** en una *migraci√≥n* como esta:

```elixir
defmodule Chuleta.Repo.Migrations.CreateArtistsTable do
  use Ecto.Migration

  def change do
    create table("artists") do
      add(:name, :string)

      timestamps()
    end
  end
end
```

* Y se ejecuta con `Ecto.Migrator` (por suerte se dispone de mucha ayuda de `mix ecto.migrate` aunque aqu√≠ no lo vamos a usar)

```elixir
Ecto.Migrator.run(Repo, [{0, Chuleta.Repo.Migrations.CreateArtistsTable}], :up, all: true)
```

* Volvemos a intentar ahora la inserci√≥n, varias veces

```elixir
Repo.insert(%Artist{})
```

* E inmediatamente la extracci√≥n

```elixir
Repo.all(Artist)
```

## Protegemos el modelo l√≥gico

* El modelo conceptual dice que la multiplicidad de `name` es [1]
* La migraci√≥n puede incluir restricciones sobre el modelo l√≥gico como `NOT NULL`:
  ```elixir
                def change do
                  create table("artists") do
                    add(:name, :string, null: false)

                    timestamps()
                  end
                end
  ```
* Vamos a hacerlo con una nueva migraci√≥n

```elixir
defmodule Chuleta.Repo.Migrations.NameNotNull do
  use Ecto.Migration

  def change do
    alter table("artists") do
      modify(:name, :string, null: false)
    end
  end
end
```

```elixir
Ecto.Migrator.run(Repo, [{1, Chuleta.Repo.Migrations.NameNotNull}], :up, all: true)
```

* Se puede hacer un ***rollback* autom√°ticamente**

```elixir
Ecto.Migrator.run(Repo, [{0, Chuleta.Repo.Migrations.CreateArtistsTable}], :down, all: true)
```

```elixir
Ecto.Migrator.run(
  Repo,
  [{0, Chuleta.Repo.Migrations.CreateArtistsTable}, {1, Chuleta.Repo.Migrations.NameNotNull}],
  :up,
  all: true
)
```

* Reintentamos la inserci√≥n esperando un error de alg√∫n tipo

```elixir
Repo.insert(%Artist{})
```

## Buscando errores m√°s org√°nicos

* Proteger el modelo l√≥gico es estupendo pero **no queremos** tener que manejar **excepciones**
* El concepto de *changeset* nos va a ayudar con ese control de errores
  ```mermaid
              graph TD;
                Data[Data / Schema] -->|Changeset.change| Changeset;
                Changeset -->|Changeset.cast, validate| Changeset;
                Changeset -->|Repo.insert, update| Schema;
  ```

```elixir
alias Ecto.Changeset
```

```elixir
%Artist{}
|> Changeset.change()
|> Changeset.validate_required([:name])
|> Repo.insert()
|> dbg()
```

* ‚úÖ Se puede intuir lo **esencial** que resulta el *changeset* en Ecto, todo gira alrededor de este importante concepto, todos **los m√≥dulos tienen funciones que admiten o generan *changesets***

## Patr√≥n: funciones que generan changesets

* Cada *schema* lleva su propia funci√≥n para generar *changesets*: `changeset`
* Dicha funci√≥n abstrae las validaciones y adaptaciones (*cast*) de datos externos

```elixir
defmodule Chuleta.Model2.Artist do
  use TypedEctoSchema
  alias Ecto.Changeset

  typed_schema "artists" do
    field(:name, :string)

    # Regalo: macro para manejar autom√°ticamente fechas de inserci√≥n y borrado
    timestamps()
  end

  @spec changeset(t() | Changeset.t(t()), map()) :: Changeset.t(t())
  def changeset(data, params) do
    data
    |> Changeset.cast(params, [:name])
    |> Changeset.validate_required([:name])
    |> Changeset.unique_constraint(:id, name: "artists_pkey")
    |> Changeset.unique_constraint(:name)
  end
end
```

```elixir
alias Chuleta.Model2.Artist
```

* Insertamos un primer artista

```elixir
{:ok, a1} =
  %Artist{}
  |> Artist.changeset(%{name: "Supertrump"})
  |> Repo.insert()
```

* Intentamos corregir el error: Supertrump -> Supertramp

```elixir
a1
|> Artist.changeset(%{name: "Supertramp"})
|> Repo.insert()
```

* Una consulta r√°pida al [*Schema API* de Repo](https://hexdocs.pm/ecto/Ecto.Repo.html#schema-api) nos indica que debemos usar `update`
* Pero adem√°s deber√≠amos volver al *schema* y mejorar la funci√≥n `changeset` como nos indica el mensaje de error (para m√°s informaci√≥n conviene bucear en el [API de Changeset](https://hexdocs.pm/ecto/Ecto.Changeset.html))

## Patr√≥n: proteger el modelo l√≥gico y los esquemas

* Parece que podemos a√±adir varias veces el mismo nombre de artista

```elixir
%Artist{} |> Artist.changeset(%{name: "Supertramp"}) |> Repo.insert()
```

```elixir
Repo.all(Artist)
```

* El modelo conceptual nos dice que `name` es [unique]
* Vamos a trasladarlo al modelo l√≥gico

```elixir
defmodule Chuleta.Repo.Migrations.AddUniqueIndexName do
  use Ecto.Migration

  def change do
    create(unique_index("artists", :name))
  end
end
```

```elixir
Ecto.Migrator.run(Repo, [{3, Chuleta.Repo.Migrations.AddUniqueIndexName}], :up, all: true)
```

```elixir
Repo.delete_all(Artist)
```

```elixir
Ecto.Migrator.run(Repo, [{3, Chuleta.Repo.Migrations.AddUniqueIndexName}], :up, all: true)
```

* Comprobamos ahora el resultado al intentar a√±adir dos artistas con el mismo nombre

## Antipatr√≥n: no usar changesets con datos "externos"

```elixir
a = Repo.get_by(Artist, name: "Supertramp")
Repo.update(%Artist{a | name: "Supertramp. The group"})
```

```elixir
Repo.insert(%Artist{name: "Pink Floyd"})
```

## Asociaciones N:1: "colecciones"

* Lo realmente importante en nuestros modelos son las asociaciones porque [las entidades son un *placebo*](https://babel.upm.es/~angel/posts/2022/03/uml-las-clases-son-un-placebo/) ü§™
* Ecto, como otras bibliotecas, ofrece una forma de capturar las asociaciones del modelo y sus multiplicidades
* Recordemos el modelo:
  ```mermaid
      classDiagram
                                  class Album {
                                    id: integer [PK]
                                    title: string [1]
                                    released: date
                                  }
                                  class Artist {
                                    id: integer [PK]
                                    name: string [1] [unique]
                                  }
                                  class Genre {
                                    id: integer [PK]
                                    name: string [1] [unique]
                                  }
                                  class Track {
                                    id: integer [PK]
                                    title: string [1]
                                    duration: integer
                                  }
                                  Album "*" -- "1" Artist
                                  Album "*" -- "1..*" Genre
                                  Album "1" -- "1..* {ordered}" Track
  ```
* Nos llevamos el modelo a *schemas* incluyendo ahora `Artist`, `Album` y su asociaci√≥n $N:1$ (**atenci√≥n a `typed_schema` y al spec de changeset**)

```elixir
defmodule Chuleta.Model3.Artist do
  use TypedEctoSchema
  alias Ecto.Changeset
  alias Chuleta.Model3.Album

  typed_schema "artists" do
    field(:name, :string)
    has_many(:albums, Album)

    timestamps()
  end

  @spec changeset(t() | Changeset.t(t()), map()) :: Changeset.t(t())
  def changeset(data, params) do
    data
    |> Changeset.cast(params, [:name])
    |> Changeset.validate_required([:name])
    |> Changeset.unique_constraint(:id, name: "artists_pkey")
    |> Changeset.unique_constraint(:name)
  end
end
```

```elixir
defmodule Chuleta.Model3.Album do
  use TypedEctoSchema
  alias Ecto.Changeset
  alias Chuleta.Model3.Artist

  typed_schema "albums" do
    field(:title, :string)
    field(:released, :date)
    belongs_to(:artist, Artist)

    timestamps()
  end

  def changeset(data, params) do
    data
    |> Changeset.cast(params, [:title, :released])
    |> Changeset.validate_required([:title, :artist_id])
    |> Changeset.unique_constraint(:id, name: "albums_pkey")
  end
end
```

* ¬øQu√© aspecto tienen ahora nuestros *datos*?

```elixir
alias Chuleta.Model3.{Artist, Album}
```

```elixir
%Artist{}
```

```elixir
%Album{}
```

* **Observar:** como era de esperar, **`belongs_to` introduce una clave *for√°nea*** (`artist_id`) en el modelo l√≥gico pero `has_many` no va a introducir nada

<!-- livebook:{"break_markdown":true} -->

* Vamos con la migraci√≥n para crear la **nueva tabla**

```elixir
defmodule Chuleta.Repo.Migrations.CreateAlbumsTable do
  use Ecto.Migration

  def change do
    create table("albums") do
      add(:title, :string, null: false)
      add(:released, :date)
      add(:artist_id, references("artists"), null: false)

      timestamps()
    end
  end
end
```

```elixir
Ecto.Migrator.run(Repo, [{4, Chuleta.Repo.Migrations.CreateAlbumsTable}], :up, all: true)
```

* Vamos a **poblar** un poquito nuestra base de datos con datos razonables, que no con gusto üòú

```elixir
Repo.delete_all(Artist)
```

```elixir
%Artist{} |> Artist.changeset(%{name: "C. Tangana"}) |> Repo.insert()
```

```elixir
tangana = Repo.get_by(Artist, name: "C. Tangana")
```

```elixir
%Album{} |> Album.changeset(%{title: "El Madrile√±o", released: "2021-02-26"})
```

## Patr√≥n: a√±adir a una "colecci√≥n" de uno en uno

* `Ecto.build_assoc` genera un nuevo *schema* (**no lo hace persistente**)

```elixir
tangana
```

```elixir
tangana |> Ecto.build_assoc(:albums)
```

* Vamos a crear un par de √°lbumes usando **dos alternativas habituales**

```elixir
tangana |> Ecto.build_assoc(:albums, title: "Idolo", released: "2017") |> Repo.insert()
```

* ¬°Eso era un antipatr√≥n! (la fecha parece ser un dato externo sobre el que no se tiene control)

```elixir
tangana
|> Ecto.build_assoc(:albums)
|> Album.changeset(%{title: "El Madrile√±o", released: "2021"})
|> Repo.insert()
```

## Preload

```elixir
tangana = Repo.get_by(Artist, name: "C. Tangana")
```

* ¬øPara qu√© est√° ese campo `albums` y **qu√© significa *not loaded***?
* Por defecto las asociaciones **no se *precargan***: **eficiencia**

```elixir
tangana |> Repo.preload(:albums)
```

```elixir
tangana.albums
```

* ¬øQu√© ha pasado, programador OO?

## Antipatr√≥n: preload => 1 + X queries

```elixir
Repo.get_by(Artist, name: "C. Tangana") |> Repo.preload(:albums)
```

## Poblado con m√°s gusto üòú

```elixir
# Por si acaso est√° en la base de datos
supertramp = Repo.get_by!(Artist, name: "Supertramp")
```

```elixir
{:ok, supertramp} = %Artist{} |> Artist.changeset(%{name: "Supertramp"}) |> Repo.insert()
```

```elixir
supertramp
```

```elixir
supertramp |> Ecto.build_assoc(:albums, title: "Crime of the century") |> Repo.insert()
```

```elixir
supertramp |> Ecto.build_assoc(:albums, title: "Crisis? What Crisis?") |> Repo.insert()
```

## Queries

* Hasta ahora nuestras queries han sido ***nimias*** (`Repo.get_by`)
* En el [*query API de Repo*](https://hexdocs.pm/ecto/Ecto.Repo.html#query-api) se pueden encontrar operaciones **m√°s potentes**

```elixir
Repo.all(Artist)
```

* ¬øY si queremos hacer una ***precarga* de todos los √°lbumes de todos los artistas**?

```elixir
for artist <- Repo.all(Artist) do
  artist |> Repo.preload(:albums)
end
```

* Ese antipatr√≥n ya lo conocemos: *1+N queries*
* ¬øPero qu√© opciones tenemos?

```elixir
Repo.all(Artist) |> Repo.preload(:albums)
```

* ¬øY el DSL de `Ecto.Query`?

```elixir
import Ecto.Query, only: [from: 2]

Repo.all(from(a in Artist, preload: :albums))
```

## Patr√≥n: preload con join

```elixir
import Ecto, only: [assoc: 3]

Repo.all(
  from(ar in Artist,
    left_join: al in assoc(ar, :albums),
    preload: [albums: al]
  )
)
```

## Manejando la colecci√≥n como un todo (WIP ‚ö†)

* Ya hemos visto que el uso de `Ecto.build_assoc` permite crear **una entrada en una colecci√≥n**
* ¬øPero qu√© pasa si necesitamos manejar **la colecci√≥n como un todo**?
* Ampliemos nuestro modelo con las **canciones en los √°lbumes**

```elixir
defmodule Chuleta.Model4.Track do
  use TypedEctoSchema
  alias Ecto.Changeset
  alias Chuleta.Model3.Album

  typed_schema "tracks" do
    field(:title, :string)
    # ordered!
    field(:index, :integer)
    belongs_to(:album, Album)

    timestamps()
  end

  def changeset(data, params) do
    data
    |> Changeset.cast(params, [:title, :index])
    |> Changeset.validate_required([:title, :index])
    |> Changeset.unique_constraint(:id, name: "tracks_pkey")
  end
end
```

* A√±adimos `has_many` *tracks* a los √°lbumes

```elixir
defmodule Chuleta.Model4.Album do
  use TypedEctoSchema
  alias Ecto.Changeset
  alias Chuleta.Model3.Artist
  alias Chuleta.Model4.Track

  typed_schema "albums" do
    field(:title, :string)
    field(:released, :date)
    belongs_to(:artist, Artist)
    has_many(:tracks, Track)

    timestamps()
  end

  def changeset(data, params) do
    data
    |> Changeset.cast(params, [:title, :released])
    |> Changeset.validate_required([:title, :artist_id])
    |> Changeset.unique_constraint(:id, name: "albums_pkey")
  end
end
```

* Y por supuesto la migraci√≥n correspondiente

```elixir
defmodule Chuleta.Repo.Migrations.CreateTracksTable do
  use Ecto.Migration

  def change do
    create table("tracks") do
      add(:title, :string, null: false)
      add(:index, :integer, null: false)
      add(:album_id, references("albums"), null: false)

      timestamps()
    end
  end
end
```

```elixir
Ecto.Migrator.run(Repo, [{5, Chuleta.Repo.Migrations.CreateTracksTable}], :up, all: true)
```

```elixir
alias Chuleta.Model4.{Album, Tracks}
```

```elixir
songs = [
  "School",
  "Bloody Well Right",
  "Hide in Your Shell",
  "Asylum",
  "Dreamer",
  "Rudy",
  "If Everyone Was Listening",
  "Crime of the Century"
]

tracks =
  for {i, t} <- Enum.zip(1..length(songs), songs) do
    %{index: i, title: t}
  end

album =
  Repo.one(
    from(al in Album,
      where: al.title == "Crisis? What Crisis?",
      left_join: ar in assoc(al, :artist),
      left_join: tr in assoc(al, :tracks),
      preload: [artist: ar, tracks: tr]
    )
  )

album |> Album.changeset(%{tracks: tracks}) |> Changeset.cast_assoc(:tracks) |> Repo.update()
```

## WIP

* Asociaciones N:N
* A√±adir todas las *restricciones* y *validaciones* que faltan (ej. en `Track` `album_id` e `index` son *unique*)

## ...Famous Last Words...

* Cuidado con `Changeset.validate_required` para claves for√°neas pq entonces no funcionan `Changeset.put_assoc` ni `Changeset.cast_assoc`

* Entender el **mapping** y los diferentes tipos (incluye listas, maps, enumerados)

* Clave **binaria** vs entera

  ```elixir
      @primary_key {:id, :binary_id, autogenerate: true}
      @foreign_key_type :binary_id
      schema "artists" ...
  ```

  > y

<!-- livebook:{"force_markdown":true} -->

```elixir
    create table("artists", primary_key: false) do
      add :id, :binary_id, primary_key: true
      ...
```

* En las migraciones se pueden codificar **todas las restricciones en SQL**
* Asociaciones **transitivas** (ej. todas las canciones de un grupo)
* Asociaciones *polim√≥rficas* (ej. urso con videos y preguntas)
* *Custom types*
* *Upserts*
* *Transactions*
* Infinidad de detalles que de un modo u otro tienen que ver con el **modelo relacional** (ej. `on_conflict`)
* Mi experiencia con este notebook (vs. slides): **a√∫n no lo tengo claro**
